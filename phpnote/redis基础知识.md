## redis基础知识

redis支持7中数据格式String，Map，list，set，sorted set，Lua Script。

### redis主要数据结构

#### SDS简单动态字符串

#### 双端列表

#### 字典

#### 压缩列表

#### 整数集合

Redis并没有直接使用这些数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种至少用到一种前面的数据结构。

### redis数据库

#### 删除过期键策略

1. 定时删除： 在设置键的过期时间的同时，创建一个定时器，让定时器在键过期的时间来临时，立即执行键的删除。
2. 惰性删除： 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的花，就删除该键。如果没有过期，则返回该键。
3. 定期删除： 每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键。至于要删除多少过期键，以及要检查多少数据库，由算法决定。

在Redis中，使用的是惰性删除和定时删除两种。

### 持续化存储 RDB 定时快照

RDB持久化功能，可以将Redis在内存中的数据状态保存在磁盘里面。

### 持续化存储 AOF

AOF持久化是通过保存Redis服务器所执行的写命令记录数据库状态。

### 事务

用Multi(Start Transaction)、Exec(Commit)、Discard(Rollback)实现。 在事务提交前，不会执行任何指令，只会把它们存到一个队列里，不影响其他客户端的操作。在事务提交时，批量执行所有指令。

Redis里的事务，与我们平时的事务概念很不一样：

它仅仅是保证事务里的操作会被连续独占的执行。因为是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。

它没有隔离级别的概念，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。


### Redis分布式锁的实现

思路很简单，主要用到的redis函数是setnx()，首先是将某一任务标识名（这里用Lock:order作为标识名的例子）作为键存到redis里，并为其设个过期时间。

对于再次Lock:order请求过来，先是通过setnx()看看是否能将Lock:order插入到redis里，可以的话就返回true，不可以就返回false。当然，在我的代码里会比这个思路复杂一些，我会在分析代码时进一步说明。

### Redis实现任务队列：

实现会用到上面的Redis分布式的锁机制，主要是用到了Redis里的有序集合这一数据结构，例如入队时，通过zset的add()函数进行入队，而出对时，可以用到zset的getScore()函数。另外还可以弹出顶部的几个任务。



