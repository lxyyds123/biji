## php内核

内容为阅读《php7内核解析》，做的笔记。

### PHP的构成

PHP的源码下有几个主要目录：SAPI、main、Zend、ext。

- SAPI是PHP的应用接口层。
- main为PHP的主要代码，主要是输入/输出、web通信，以及PHP框架的初始化操作等。
- Zend是PHP的解析器的主要实现，即ZendVM，它是PHP语言的核心实现。
- ext是PHP的扩展目录。

### PHP的生命周期

- 模块初始化阶段
- 请求初始化阶段
- 执行脚本阶段
- 请求关闭阶段
- 模块关闭阶段

### SAPI

SAPI是PHP框架的接口层，他是进入PHP内部的入口。PHP实现的SAPI有很多，比较典型的有：CLI、FPM、Embed。

#### CLI（命令行接口）

用于在命令行下执行PHP脚本，它是执行PHP脚本最简便的一种方式。

CLI的生命周期是典型的PHP生命周期，先后经历模块初始化阶段（module startup）、请求初始化阶段（request startup）、执行脚本阶段（execute script）、请求关闭阶段（request shutdown）、模块关闭阶段（module shutdown）。

从PHP5.4起，CLI SAPI提供了一个内置的Web服务器，这个内置的服务器主要用于本地开发使用，不可用于线上产品环境。默认执行目录内的index.php或者index.html。

#### FPM

Fpm是PHP FastCGI运行模式的一个进程管理器。FastCGI是Web服务器（如：Nginx、Apache）和处理程序之间的一种通信协议。

Fpm是一种多进程模型，它由一个master进程和多个worker进程组成。master进程启动时会创建一个socket，但是不会接收、处理请求，而是fork出的worker子进程，比如当请求比较多，work进程处理不过来，master进程会尝试fork新的worker进程进行处理，而当空闲时，worker进程比较多时则会杀掉部分子进程。

每个worker进程会竞争Accept请求，接收成功后，解析FastCGI，然后执行相应的脚本。处理完成后，关闭请求，继续等待新的请求。

master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等，master进程通过发送信号等方式杀掉worker进程。

#### Embed

Embed在编译后就是普通的库文件（可以编译成静态库、共享库），通过API的方式提供给其它语言使用。

### 内存管理

PHP中数据类型的实现，主要为zval、zend_value两个结构体。

#### 变量的自动GC机制

自动GC机制引用记数+写时复制的方式，在变量赋值和传递时不是直接进行深拷贝，在函数执行完毕后将内存释放，达到回收内存的机制。

引用记数用来记录当前有多少个zval指向同一个zend_value。当有新的zval指向这个zend_value时，引用记数计数器refcount加1，当zval销毁时，refcount减1。当refcount为0时，zend_value将被释放。

写时复制的机制在计算机中广泛应用，只有在必要的时候（即发生写的时候）才会进行深度拷贝，可以很好的提升效率，例如Linux操作系统中fork子进程时并不会立即复制父进程的地址空间，而是让那个父子进程共享同一个地址空间，只有在需要写如的时候此才会复制抵制空间，从而使各个进程拥有各自的抵制空间。

#### 垃圾回收

当变量被循环引用时，自动GC机制就无法进行有效回收，这样内存就始终得不到释放，造成内存泄漏。

垃圾回收器的两个准则：

- 如果一个变量的refcount减少到0，那么此value可以被释放，不属于垃圾。
- 如果一个变量的refcount减少之后大于0，那么此zend_value不会被释放，但是可能成为一个垃圾。

垃圾回收器会把可能成为垃圾到zend_value收集起来，等达到一定数量后，开始启动垃圾鉴定程序，把真正到垃圾释放掉。

#### 内存池

在C语言中，通常直接使用malloc进行内存分配，而频繁地分配、释放内存无疑会产生内存碎片，降低系统性能。在PHP中，变量到分配、释放非常频繁，如果所有变量都通过malloc到方式进行分配，那么将造成严重到性能问题。为此，PHP自己实现了一套内存池（ZendMM：Zend Memery Manager）。内存池技术主要有两方面到作用：减少内存分配及释放的次数、有效控制内存碎片化到产生。

内存池是PHP内核中最底层到内存操作，内存池定义了三种粒度到内存块：chunk、page、slot，每个chunk到大小为2MB，page为4KB，一个chunk被切割为512个page，而一个或若干个page被切割为多个slot。申请内存时按照不同到申请大小决定具体到分配策略。

### PHP到编译与执行

编程语言可分为编译型和解释型。编译型语言是指程序在运行前提前编译为计算机可执行的二进制文件，在执行时直接执行机器指令。解释型语言是指程序在运行时有解析器边编译边执行，也称为脚本语言。

#### 编译型语言

编译型语言在执行前编译器根据不同的机器类型将高级语言生成对应的低级机器语言指令，然后将这些机器语言指令按照可以执行目标程序的格式存储在磁盘中，执行时再按照可执行程序的格式将其加载到内存中对应位置（数据段、代码段），最后逐条执行机器指令。

以C语言为例，Linux下由GCC编译器读取程序的源文件，经过预处理、编译、汇编、链接的哥过程，将定义的C语言代码编译为可执行的目标程序。

#### 解释型语言

解释型语言与编译型语言的根本区别在于，它在执行前不需要编译为机器语言，而是由解释器进行解析执行，解释器为机器可识别的二进制程序，也就是说，解释型语言实际上是在语言与实际计算机中间加了一层解释器，称为虚拟机，然后通过解释型语言控制编译好的解释器执行相应的机器指令。

#### Zend虚拟机

Zend虚拟机（ZendVM）是PHP语言的解释器，负责PHP代码的解析和执行。ZendVM对于实际的计算机而言是二进制可执行程序，

ZendVM由两部分组成：编译器、执行器，其中编译器负责将PHP代码解释为ZendVM可识别的指令（即opline），同时生成对应的符号表（函数、类等），执行器负责执行opcode对应的机器指令。

#### JIT（just-in-time）

PHP属于动态编译，即只有在运行时进行编译，且通过解释器转为可执行的机器指令。而静态编译是在运行前编译，而且是编译为机器指令。

JIT与两者不同，他在运行时进行编译，而且不会把所有代码全部编译为机器码，只会编译频繁执行的代码，且将源码编译为机器指令。

### 面向对象

面向对象编程，简称OOP，是一种程序设计思路。面向对象吧对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

面向对象的特点：

- 封装：将类中的成员属性和方法结合成一个独立的单位，确保类以外的部分不能随意存取类的内部数据。
- 继承：一个类可以继承并拥有另外一个类的成员属性和成员方法。
- 多肽：程序能够处理多种类型对象的能力，PHP中可以通过继承和接口两种方式实现多肽。

### 类

一个类可以包含属于自己的常量、变量（称为“属性”）与函数（称为“方法”），在面向对象中的编程中，类是对象的抽象，对象是类的具体实例。

#### 常量

PHP中可以把在类中始终保持不变的值定义为常量，常量的值必须是一个定值。

```php
class my_class{
    const CONST_NAME = const_value;
    public function __construct(){
        self::CONST_NAME;
    }
}
my_class::CONST_NAME;
```

#### 成员属性

类的属性由关键字 public、protected和private开头，属性中的变量可以初始化，但初始化的值必须是固定不变的值，不能是变量，初始化值在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。

#### 成员方法

分为静态方法和动态方法。

#### 类的自动加载

类的自动加载实际上就是内核提供的一个钩子函数，实例化类时如果在EG（class_table）中没有找到对应的类，则会调用这个钩子函数，调用完以后再重新查找一次。

PHP中提供了两种方式实现自动加载，__autoload(),spl_autoload_register()。

spl_autoload_register

相比__autoload只能定义一个加载器，spl_autoload_register提供类更加灵活的注册方式，可以支持任意数量的加载器，比如在不同lib库的文件名规则。

在实现上，spl创建类一个队列来保存用户注册的加载器，然后定义类一个spl_autoload_call函数到EG，当找不到类时，内核回调spl_autoload_call，这个函数在依次调用用户注册的加载器。

#### 魔术方法

- __construct()
- __destruct()
- __call()
- __callStatic()
- __get()
- __set()
- __isset()
- __unset()
- __sleep()
- __wakeup()
- __toString()
- __invoke()
- __set_state()
- __clone()
- __debugInfo()

### 命名空间

命名空间主来用来解决两类问题：

- 用户编写的代码与PHP内部的或第三方的类、函数、变量、接口命名冲突。
- 为很长的标识符名称创建一个别名的名称，提高源代码的可读性。
- PHP命名空间只能隔离类、函数、常量和接口，不包括全局变量。

### PHP基础语法的实现

#### 静态变量（static）

静态变量和普通变量的存储结构不同，保存在zend_op_array->static_variables中，是一种哈希结构。静态变量只会初始化一次，而且他的初始化发生在变异阶段而不是执行阶段。因为这个特性，静态变量的初始不能是个变量。但在执行阶段，可以动态赋值。

```php
function my_func(){
    static $count = 4;
    $count++;
    echo $count;
}
my_func();
my_func();
//输出5
//输出6
```

上面代码中，在编译阶段静态变量就会初始化一次，而在执行阶段不会在设置该值。在执行阶段，改变值后，内存不会被回收，所以两次输出结果不同。

#### 常量（const define）

常量是一种简单值的标识符，在脚本执行期间该值不能改变。

常量默认大小写敏感，通常常量标识符总是大写的。合法的常量名以字母或下划线开始，后面跟着任何字母、数字和下划线。

##### const关键字

```
const AA = 100;
const AA = 100, BB = 200;
```

##### define函数

define可以定义值为变量的常量，但是变量的值必须也是标量。

```
$a = array(1,2);
define('AA', $a);
```